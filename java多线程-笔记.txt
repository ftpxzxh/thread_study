
1、创建线程的两种方式：
	看类TraditionalThread
获取当前线程的名字：Thread.currentThread().getName()

2、定时器的应用
	看类TraditionalTimerTest

3、线程的同步synchronized
	看类TraditionalThreadSynchronized

4、一道面试题目（线程间的通信问题，wait()和notify()，必须写在synchronized的里面，并且调用wait()和notify()的对象为锁对象）
	子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出代码
	
	1）先实现子线程运行10次，主线程运行100次，如此循环50次；
	2）使用wait()和notify()实现线程间的通信，使得主线程和子线程交替运行
	
	看类TraditionalThreadCommunication
	
5、线程内的共享数据（ThreadLocal）
	问题引入：看类ThreadScopeShareDataHasMistake
	ThreadLocal的原理：看类ThreadScopeShareData
	ThreadLocal的使用和设计：ThreadLocalTest

6、面试题目（多个线程访问共享数据）
	面试宝典28、设计4个线程，其中两个线程每次对j加1，另外两个线程每次对j减1，写出程序
	看类MultiThreadShareData

以上是java5之前的多线程知识

java5以后的线程新知识
1、java5原子性操作类的应用-atomic
	AtomicInteger、AtomicIntegerArray、AtomicIntegerFieldUpdater

2、线程池Executors
	看类ThreadPoolTest
	
3、Callable与Future的应用
	看类CallableAndFuture
	
4、Lock(用来替换synchronized)
	1）看类LockTest，介绍了ReentrantLock的使用
	2）看类ReadWriteLockTest，介绍了ReadWriteLock接口和其子类ReentrantReadWriteLock的使用
	面试题目：设计一个缓存系统 看类CacheDemo
	示例用法。下面的代码展示了如何利用重入来执行升级缓存后的锁降级（为简单起见，省略了异常处理）： 

JDK中的ReentrantReadWriteLock文档中有这么一段示例代码
 class CachedData {
   Object data;
   volatile boolean cacheValid;
   ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

   void processCachedData() {
     rwl.readLock().lock();
     if (!cacheValid) {
        // Must release read lock before acquiring write lock
        rwl.readLock().unlock();
        rwl.writeLock().lock();
        // Recheck state because another thread might have acquired
        //   write lock and changed state before we did.
        if (!cacheValid) {
          data = ...
          cacheValid = true;
        }
        // Downgrade by acquiring read lock before releasing write lock
        rwl.readLock().lock();
        rwl.writeLock().unlock(); // Unlock write, still hold read
     }

     use(data);
     rwl.readLock().unlock();
   }
 }
 第一次读的时候，上读锁，使得写的线程不能进来；
但是第一次读的时候发现cacheValid是false，即还没有缓存，所以就先把读锁释放，然后上写锁；
如果读锁切换成写锁的过程中，缓存cacheValid还是false，表示没有其他线程缓存过，这时候就在加写锁的情况下进行数据的缓存，缓存完成后，就把缓存标志位变为true，最后上读锁，并把写锁释放；
然后就可以使用缓存数据了，使用完成后，就把读锁释放掉

6、Condition实现线程同步通信（用来替换之前学的await()和notify()）
	看类ConditionCommunication
	Condition condition = lock.newCondition();
	condition.await();
	condition.signal();
	用condition可以实现多路等待和通知
作为一个示例，假定有一个绑定的缓冲区，它支持 put 和 take 方法。如果试图在空的缓冲区上执行 take 操作，则在某一个项变得可用之前，线程将一直阻塞；
如果试图在满的缓冲区上执行 put 操作，则在有空间变得可用之前，线程将一直阻塞。
我们喜欢在单独的等待 set 中保存 put 线程和 take 线程，这样就可以在缓冲区中的项或空间变得可用时利用最佳规划，一次只通知一个线程。
可以使用两个 Condition 实例来做到这一点。
 class BoundedBuffer {
   final Lock lock = new ReentrantLock();
   final Condition notFull  = lock.newCondition(); 
   final Condition notEmpty = lock.newCondition(); 

   final Object[] items = new Object[100];
   int putptr, takeptr, count;

   public void put(Object x) throws InterruptedException {
     lock.lock();
     try {
       while (count == items.length) //如果已经满了，那么没有放满的线程就要等待
         notFull.await();
       items[putptr] = x; 
       if (++putptr == items.length) putptr = 0;
       ++count;
       notEmpty.signal();			//缓冲区有一个已经放入了，就通知不是空的取的线程去取
     } finally {
       lock.unlock();
     }
   }

   public Object take() throws InterruptedException {
     lock.lock();
     try {
       while (count == 0) 
         notEmpty.await();
       Object x = items[takeptr]; 
       if (++takeptr == items.length) takeptr = 0;
       --count;
       notFull.signal();
       return x;
     } finally {
       lock.unlock();
     }
   } 
 }
 
 灵活运用Condition
 	看类ThreeConditionCommunication
	1走完通知2走，2走完通知3走，3走完通知1走；如此循环

7、Semaphore实现信号灯 可用于控制同时访问资源的线程个数
	看类SemaphoreTest

8、CyclicBarrier   彼此等待，集合后再共同出发
 	看类CyclicBarrierTest
	
9、CountdownLatch 类似于百米赛跑
	看类CountdownLatchTest
	
10.Exchanger 线程间的数据交换
	看类ExchangerTest